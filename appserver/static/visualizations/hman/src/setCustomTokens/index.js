const SplunkVisualizationBase = require('api/SplunkVisualizationBase'); // eslint-disable-line no-unused-vars
/**
 * Emits a native-style Simple XML drilldown event scoped to this component.
 *
 * Token lifecycle (mirrors visualizationview._emitDrilldownEvent → eventhandler.handleEvent):
 *   1. Build a drilldown data object with click.* and row.* fields
 *   2. Wrap it in a payload with preventDefault/drilldown helpers
 *   3. Trigger 'drilldown' on the component — the EventHandler that is
 *      bound to THIS component's viewid picks it up and resolves
 *      $row.<field>$, $click.value$, etc. from e.data into named tokens.
 *   4. Only explicitly <set> tokens are written to global token models.
 *      row.* / click.* stay inside the event payload (component-scoped).
 */
const _setCustomTokens = function (params, tmpChartInstance) {

    var mvc = this.splunkjs.mvc;

    // Get component ID
    var splunkAutoGeneratedComponentId = tmpChartInstance._dom.closest('.dashboard-element.viz')?.id;
    var activeVizComponent = mvc.Components.get(splunkAutoGeneratedComponentId);

    if (!activeVizComponent) {
        console.warn('_setCustomTokens: could not resolve viz component for drilldown');
        return;
    }

    // ── 1. Build normalised drilldown data (same shape as normalizeDrilldownEventData) ──
    var drilldownData = {};

    if (params.dimensionNames && params.data.value) {
        // Populate row.<fieldName> tokens — carried inside the event, NOT on global models
        params.dimensionNames.forEach(function (dimensionName, index) {
            if (params.data.value[index] !== undefined) {
                drilldownData['row.' + dimensionName] = String(params.data.value[index]);
            }
        });

        // ── click.name / click.value (e.name / e.value) ──
        // Primary clicked dimension: the category field (index 3).
        // params.name holds the ECharts data item's name (set to the category value
        // in buildTimelineOption), which is the value the user actually clicked on.
        // The corresponding field name is dimensionNames[3].
        var clickName  = params.dimensionNames[3] || '';
        var clickValue = params.name !== undefined ? String(params.name) : '';

        drilldownData['click.name']  = clickName;
        drilldownData['click.value'] = clickValue;

        // ── click.name2 / click.value2 (e.name2 / e.value2) ──
        // Secondary dimension: the internal_name / series field (index 2).
        // Mirrors Splunk's normalizeDrilldownEventData: use name2 when present,
        // otherwise fall back to the same values as click.name / click.value.
        if (params.dimensionNames.length > 2 && params.data.value[2] !== undefined) {
            drilldownData['click.name2']  = params.dimensionNames[2];
            drilldownData['click.value2'] = String(params.data.value[2]);
        } else {
            drilldownData['click.name2']  = clickName;
            drilldownData['click.value2'] = clickValue;
        }
    }

    // ── 2. Build the event payload (same contract as Drilldown.createEventPayload) ──
    var defaultPrevented = false;
    var drilldownPayload = {
        field: drilldownData['click.name2'] || drilldownData['click.name'] || '',
        data:  drilldownData,
        event: params,
        preventDefault: function () {
            defaultPrevented = true;
        },
        defaultPrevented: function () {
            return defaultPrevented;
        },
        drilldown: function () { /* no-op — default action handled by EventHandler */ }
    };

    // ── 3. Trigger on the component so EventHandler (bound via viewid) picks it up ──
    activeVizComponent.trigger('drilldown', drilldownPayload);
}

module.exports = _setCustomTokens;